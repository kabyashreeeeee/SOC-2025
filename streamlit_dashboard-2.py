# -*- coding: utf-8 -*-
"""Streamlit_dashboard.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1QnaM0Dh-sTZ37PcclCJ-q-shOYfAp8c4
"""

!pip install plotly pandas numpy yfinance streamlit scikit-learn torch gymnasium stable-baselines3 matplotlib seaborn ta
import streamlit as st
import pandas as pd
import numpy as np
import plotly.graph_objects as go
import plotly.express as px
from plotly.subplots import make_subplots
import yfinance as yf
from datetime import datetime, timedelta
import json
import pickle
import os

# Import our main trading system
from drl_trading_system import DataPipeline, TradingEnvironment, DQNAgent, PPOAgent, TradingTrainer

# Configure Streamlit page
st.set_page_config(
    page_title="DRL Trading System Dashboard",
    page_icon="üìà",
    layout="wide",
    initial_sidebar_state="expanded"
)

# Custom CSS
st.markdown("""
<style>
    .main-header {
        font-size: 2.5rem;
        font-weight: bold;
        color: #1f77b4;
        text-align: center;
        margin-bottom: 2rem;
    }
    .metric-container {
        background-color: #f0f2f6;
        padding: 1rem;
        border-radius: 0.5rem;
        margin: 0.5rem 0;
    }
    .performance-card {
        background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
        color: white;
        padding: 1.5rem;
        border-radius: 1rem;
        margin: 1rem 0;
        text-align: center;
    }
</style>
""", unsafe_allow_html=True)

# Initialize session state
if 'pipeline' not in st.session_state:
    st.session_state.pipeline = None
if 'results' not in st.session_state:
    st.session_state.results = {}
if 'trained_agents' not in st.session_state:
    st.session_state.trained_agents = {}

# Main header
st.markdown('<h1 class="main-header">üöÄ Deep Reinforcement Learning Trading System</h1>', unsafe_allow_html=True)

# Sidebar
st.sidebar.title("Navigation")
page = st.sidebar.selectbox("Choose a page", [
    "Overview",
    "Data Pipeline",
    "Agent Training",
    "Performance Analysis",
    "Live Trading Simulation",
    "Model Comparison"
])

# Data loading functions
@st.cache_data
def load_data():
    """Load and process data with caching"""
    pipeline = DataPipeline()
    pipeline.fetch_data()
    pipeline.process_all_assets()
    return pipeline

def save_results(results, filename="trading_results.pkl"):
    """Save results to file"""
    with open(filename, 'wb') as f:
        pickle.dump(results, f)

def load_results(filename="trading_results.pkl"):
    """Load results from file"""
    try:
        with open(filename, 'rb') as f:
            return pickle.load(f)
    except FileNotFoundError:
        return {}

# ============================================================================
# OVERVIEW PAGE
# ============================================================================

if page == "Overview":
    st.header("üìä System Overview")

    col1, col2, col3 = st.columns(3)

    with col1:
        st.markdown("""
        <div class="performance-card">
            <h3>üéØ Objective</h3>
            <p>Develop and compare DRL agents for automated stock trading using technical indicators and market data.</p>
        </div>
        """, unsafe_allow_html=True)

    with col2:
        st.markdown("""
        <div class="performance-card">
            <h3>ü§ñ Agents</h3>
            <p>DQN (Deep Q-Network) and PPO (Proximal Policy Optimization) agents with neural network policies.</p>
        </div>
        """, unsafe_allow_html=True)

    with col3:
        st.markdown("""
        <div class="performance-card">
            <h3>üìà Assets</h3>
            <p>AAPL, MSFT, GOOGL, TSLA with 6 years of historical data and 25+ technical indicators.</p>
        </div>
        """, unsafe_allow_html=True)

    st.subheader("üîß System Architecture")

    # Architecture diagram (simplified)
    fig = go.Figure()
    fig.add_shape(
        type="rect", x0=0, y0=0, x1=2, y1=1,
        line=dict(color="blue"), fillcolor="lightblue"
    )
    fig.add_annotation(x=1, y=0.5, text="Data Pipeline<br>Technical Indicators", showarrow=False)

    fig.add_shape(
        type="rect", x0=3, y0=0, x1=5, y1=1,
        line=dict(color="green"), fillcolor="lightgreen"
    )
    fig.add_annotation(x=4, y=0.5, text="Trading Environment<br>State/Action/Reward", showarrow=False)

    fig.add_shape(
        type="rect", x0=6, y0=0, x1=8, y1=1,
        line=dict(color="red"), fillcolor="lightcoral"
    )
    fig.add_annotation(x=7, y=0.5, text="DRL Agents<br>DQN/PPO", showarrow=False)

    # Add arrows
    fig.add_annotation(x=2.5, y=0.5, text="‚Üí", showarrow=False, font=dict(size=20))
    fig.add_annotation(x=5.5, y=0.5, text="‚Üí", showarrow=False, font=dict(size=20))

    fig.update_layout(
        title="DRL Trading System Architecture",
        xaxis=dict(range=[-0.5, 8.5], showgrid=False, showticklabels=False),
        yaxis=dict(range=[-0.5, 1.5], showgrid=False, showticklabels=False),
        height=200
    )

    st.plotly_chart(fig, use_container_width=True)

    st.subheader("üìã Key Features")

    features = [
        "üîç Comprehensive technical indicator calculation (RSI, MACD, Bollinger Bands, etc.)",
        "üß† Deep Q-Network (DQN) and Proximal Policy Optimization (PPO) agents",
        "üéØ Multi-asset trading with risk management",
        "üìä Real-time performance monitoring and visualization",
        "üîÑ Backtesting and forward testing capabilities",
        "üíæ Model persistence and result caching"
    ]

    for feature in features:
        st.write(feature)

# ============================================================================
# DATA PIPELINE PAGE
# ============================================================================

elif page == "Data Pipeline":
    st.header("üìà Data Pipeline & Feature Engineering")

    # Load data button
    if st.button("üîÑ Load Fresh Data"):
        with st.spinner("Loading data..."):
            st.session_state.pipeline = load_data()
        st.success("Data loaded successfully!")

    # Check if data is loaded
    if st.session_state.pipeline is None:
        st.warning("Please load data first using the button above.")
        st.stop()

    pipeline = st.session_state.pipeline

    # Data overview
    st.subheader("üìä Data Overview")

    if pipeline.processed_data:
        # Create summary table
        summary_data = []
        for symbol in pipeline.assets:
            if symbol in pipeline.processed_data:
                data = pipeline.processed_data[symbol]['clean']
                summary_data.append({
                    'Symbol': symbol,
                    'Records': len(data),
                    'Features': len(data.columns),
                    'Start Date': data.index[0].strftime('%Y-%m-%d'),
                    'End Date': data.index[-1].strftime('%Y-%m-%d'),
                    'Latest Price': f"${data['Close'].iloc[-1]:.2f}"
                })

        summary_df = pd.DataFrame(summary_data)
        st.dataframe(summary_df, use_container_width=True)

        # Feature categories
        st.subheader("üîß Feature Categories")

        col1, col2 = st.columns(2)

        with col1:
            st.markdown("""
            **Trend Indicators:**
            - SMA (20, 50)
            - EMA (20)
            - MACD & Signal

            **Momentum Indicators:**
            - RSI (14)
            - Stochastic (K, D)
            - Williams %R
            - ROC
            """)

        with col2:
            st.markdown("""
            **Volatility Indicators:**
            - ATR (14)
            - Bollinger Bands
            - Volatility Regime

            **Volume Indicators:**
            - Volume SMA
            - Volume Ratio
            - Relative Volume
            """)

        # Interactive chart
        st.subheader("üìä Interactive Price Chart")

        selected_symbol = st.selectbox("Select Symbol", pipeline.assets)

        if selected_symbol in pipeline.processed_data:
            data = pipeline.processed_data[selected_symbol]['clean']

            # Create candlestick chart
            fig = make_subplots(
                rows=3, cols=1,
                subplot_titles=('Price & Moving Averages', 'RSI', 'MACD'),
                vertical_spacing=0.1,
                row_heights=[0.6, 0.2, 0.2]
            )

            # Candlestick chart
            fig.add_trace(
                go.Candlestick(
                    x=data.index,
                    open=data['Open'],
                    high=data['High'],
                    low=data['Low'],
                    close=data['Close'],
                    name='Price'
                ),
                row=1, col=1
            )

            # Moving averages
            fig.add_trace(
                go.Scatter(x=data.index, y=data['SMA_20'], name='SMA 20', line=dict(color='orange')),
                row=1, col=1
            )
            fig.add_trace(
                go.Scatter(x=data.index, y=data['EMA_20'], name='EMA 20', line=dict(color='red')),
                row=1, col=1
            )

            # RSI
            fig.add_trace(
                go.Scatter(x=data.index, y=data['RSI'], name='RSI', line=dict(color='purple')),
                row=2, col=1
            )
            fig.add_hline(y=70, line_dash="dash", line_color="red", row=2, col=1)
            fig.add_hline(y=30, line_dash="dash", line_color="green", row=2, col=1)

            # MACD
            fig.add_trace(
                go.Scatter(x=data.index, y=data['MACD'], name='MACD', line=dict(color='blue')),
                row=3, col=1
            )
            fig.add_trace(
                go.Scatter(x=data.index, y=data['MACD_signal'], name='Signal', line=dict(color='red')),
                row=3, col=1
            )

            fig.update_layout(
                title=f"{selected_symbol} Technical Analysis",
                height=800,
                showlegend=True
            )

            st.plotly_chart(fig, use_container_width=True)

            # Correlation matrix
            st.subheader("üîó Feature Correlation Matrix")

            # Select key features for correlation
            corr_features = ['Close', 'RSI', 'MACD', 'ATR', 'STOCH_K', 'Volume_ratio', 'BB_position']
            corr_data = data[corr_features].corr()

            fig_corr = px.imshow(
                corr_data,
                labels=dict(x="Features", y="Features", color="Correlation"),
                x=corr_features,
                y=corr_features,
                color_continuous_scale='RdBu',
                aspect="auto"
            )
            fig_corr.update_layout(title="Feature Correlation Matrix")
            st.plotly_chart(fig_corr, use_container_width=True)

# ============================================================================
# AGENT TRAINING PAGE
# ============================================================================

elif page == "Agent Training":
    st.header("ü§ñ Agent Training & Configuration")

    # Check if data is loaded
    if st.session_state.pipeline is None:
        st.warning("Please load data first from the Data Pipeline page.")
        st.stop()

    pipeline = st.session_state.pipeline

    # Training configuration
    st.subheader("‚öôÔ∏è Training Configuration")

    col1, col2 = st.columns(2)

    with col1:
        agent_type = st.selectbox("Select Agent Type", ["DQN", "PPO"])
        selected_symbols = st.multiselect("Select Assets", pipeline.assets, default=pipeline.assets[:2])
        episodes = st.slider("Training Episodes", 100, 2000, 500)

    with col2:
        learning_rate = st.number_input("Learning Rate", 0.0001, 0.01, 0.001, format="%.4f")
        batch_size = st.number_input("Batch Size", 16, 128, 32)

        if agent_type == "DQN":
            epsilon_decay = st.number_input("Epsilon Decay", 0.990, 0.999, 0.995, format="%.3f")
        else:  # PPO
            clip_epsilon = st.number_input("Clip Epsilon", 0.1, 0.3, 0.2, format="%.1f")

    # Training button
    if st.button("üöÄ Start Training"):
        if not selected_symbols:
            st.error("Please select at least one asset.")
            st.stop()

        progress_bar = st.progress(0)
        status_text = st.empty()

        training_results = {}

        for i, symbol in enumerate(selected_symbols):
            status_text.text(f"Training {agent_type} agent on {symbol}...")

            # Create trainer
            trainer = TradingTrainer(pipeline, agent_type)

            # Train agent
            with st.spinner(f"Training {agent_type} on {symbol}..."):
                agent, performance = trainer.train_agent(symbol, episodes)

                training_results[f"{agent_type}_{symbol}"] = {
                    'agent': agent,
                    'performance': performance,
                    'trainer': trainer
                }

            progress_bar.progress((i + 1) / len(selected_symbols))

        # Store results
        st.session_state.results.update(training_results)
        st.session_state.trained_agents.update(training_results)

        # Save results
        save_results(st.session_state.results)

        status_text.text("Training completed!")
        st.success(f"Successfully trained {agent_type} agents on {len(selected_symbols)} assets!")

        # Display training summary
        st.subheader("üìä Training Summary")

        summary_data = []
        for key, result in training_results.items():
            agent_type_name, symbol = key.split('_', 1)
            performance = result['performance']
            summary_data.append({
                'Agent': agent_type_name,
                'Symbol': symbol,
                'Total Return': f"{performance['total_return']:.2%}",
                'Sharpe Ratio': f"{performance['sharpe_ratio']:.3f}",
                'Trades': performance['num_trades'],
                'Max Drawdown': f"{performance['max_drawdown']:.2%}"
            })

        summary_df = pd.DataFrame(summary_data)
        st.dataframe(summary_df, use_container_width=True)

    # Display existing results
    if st.session_state.results:
        st.subheader("üóÇÔ∏è Existing Training Results")

        existing_results = []
        for key, result in st.session_state.results.items():
            try:
                agent_type_name, symbol = key.split('_', 1)
                performance = result['performance']
                existing_results.append({
                    'Agent': agent_type_name,
                    'Symbol': symbol,
                    'Total Return': f"{performance['total_return']:.2%}",
                    'Sharpe Ratio': f"{performance['sharpe_ratio']:.3f}",
                    'Trades': performance['num_trades'],
                    'Max Drawdown': f"{performance['max_drawdown']:.2%}"
                })
            except:
                continue

        if existing_results:
            existing_df = pd.DataFrame(existing_results)
            st.dataframe(existing_df, use_container_width=True)

            # Clear results button
            if st.button("üóëÔ∏è Clear All Results"):
                st.session_state.results = {}
                st.session_state.trained_agents = {}
                st.success("All results cleared!")

# ============================================================================
# PERFORMANCE ANALYSIS PAGE
# ============================================================================

elif page == "Performance Analysis":
    st.header("üìä Performance Analysis")

    # Check if results exist
    if not st.session_state.results:
        st.warning("No trained agents found. Please train some agents first.")
        st.stop()

    # Results selector
    result_keys = list(st.session_state.results.keys())
    selected_result = st.selectbox("Select Trained Agent", result_keys)

    if selected_result:
        result = st.session_state.results[selected_result]
        performance = result['performance']
        trainer = result['trainer']

        # Performance metrics
        st.subheader("üìà Performance Metrics")

        col1, col2, col3, col4 = st.columns(4)

        with col1:
            st.metric("Total Return", f"{performance['total_return']:.2%}")

        with col2:
            st.metric("Sharpe Ratio", f"{performance['sharpe_ratio']:.3f}")

        with col3:
            st.metric("Number of Trades", performance['num_trades'])

        with col4:
            st.metric("Max Drawdown", f"{performance['max_drawdown']:.2%}")

        # Additional metrics
        col5, col6, col7, col8 = st.columns(4)

        with col5:
            st.metric("Final Balance", f"${performance['final_balance']:.2f}")

        with col6:
            st.metric("Final Shares", performance['final_shares'])

        with col7:
            st.metric("Net Worth", f"${performance['net_worth']:.2f}")

        with col8:
            roi = (performance['net_worth'] - 10000) / 10000
            st.metric("ROI", f"{roi:.2%}")

        # Training progress charts
        if selected_result in trainer.results:
            training_data = trainer.results[selected_result.split('_', 1)[1]]

            st.subheader("üìä Training Progress")

            col1, col2 = st.columns(2)

            with col1:
                # Training rewards
                fig_rewards = go.Figure()
                fig_rewards.add_trace(go.Scatter(
                    y=training_data['training_rewards'],
                    mode='lines',
                    name='Episode Rewards',
                    line=dict(color='blue')
                ))

                # Add moving average
                window = 50
                if len(training_data['training_rewards']) > window:
                    ma_rewards = np.convolve(training_data['training_rewards'],
                                           np.ones(window)/window, mode='valid')
                    fig_rewards.add_trace(go.Scatter(
                        y=ma_rewards,
                        mode='lines',
                        name=f'MA({window})',
                        line=dict(color='red')
                    ))

                fig_rewards.update_layout(
                    title="Training Rewards",
                    xaxis_title="Episode",
                    yaxis_title="Reward"
                )
                st.plotly_chart(fig_rewards, use_container_width=True)

            with col2:
                # Training returns
                fig_returns = go.Figure()
                fig_returns.add_trace(go.Scatter(
                    y=training_data['training_returns'],
                    mode='lines',
                    name='Episode Returns',
                    line=dict(color='green')
                ))

                # Add moving average
                if len(training_data['training_returns']) > window:
                    ma_returns = np.convolve(training_data['training_returns'],
                                           np.ones(window)/window, mode='valid')
                    fig_returns.add_trace(go.Scatter(
                        y=ma_returns,
                        mode='lines',
                        name=f'MA({window})',
                        line=dict(color='orange')
                    ))

                fig_returns.update_layout(
                    title="Training Returns",
                    xaxis_title="Episode",
                    yaxis_title="Return"
                )
                st.plotly_chart(fig_returns, use_container_width=True)

        # Trading actions visualization
        st.subheader("üéØ Trading Actions")

        if 'test_env' in training_data:
            test_env = training_data['test_env']

            if test_env.trades:
                # Create trades DataFrame
                trades_df = pd.DataFrame(test_env.trades)

                # Trading actions pie chart
                action_counts = trades_df['action'].value_counts()

                fig_actions = go.Figure(data=[go.Pie(
                    labels=action_counts.index,
                    values=action_counts.values,
                    hole=0.3
                )])

                fig_actions.update_layout(
                    title="Trading Actions Distribution",
                    showlegend=True
                )
                st.plotly_chart(fig_actions, use_container_width=True)

                # Trades table
                st.subheader("üìã Trade History")
                st.dataframe(trades_df, use_container_width=True)

        # Comparison with buy-and-hold
        st.subheader("üÜö Buy-and-Hold Comparison")

        agent_type, symbol = selected_result.split('_', 1)

        # Get original data
        if st.session_state.pipeline and symbol in st.session_state.pipeline.processed_data:
            original_data = st.session_state.pipeline.processed_data[symbol]['clean']

            # Calculate buy-and-hold return
            train_size = int(len(original_data) * 0.8)
            test_data = original_data[train_size:]

            if len(test_data) > 0:
                buy_hold_return = (test_data['Close'].iloc[-1] - test_data['Close'].iloc[0]) / test_data['Close'].iloc[0]

                comparison_data = {
                    'Strategy': ['DRL Agent', 'Buy & Hold'],
                    'Return': [performance['total_return'], buy_hold_return],
                    'Sharpe': [performance['sharpe_ratio'], 0]  # Simplified
                }

                comparison_df = pd.DataFrame(comparison_data)

                fig_comparison = px.bar(
                    comparison_df,
                    x='Strategy',
                    y='Return',
                    title='DRL Agent vs Buy & Hold Performance',
                    color='Strategy'
                )

                st.plotly_chart(fig_comparison, use_container_width=True)

                # Performance summary
                if performance['total_return'] > buy_hold_return:
                    st.success(f"üéâ DRL Agent outperformed Buy & Hold by {(performance['total_return'] - buy_hold_return):.2%}")
                else:
                    st.info(f"üìä Buy & Hold outperformed DRL Agent by {(buy_hold_return - performance['total_return']):.2%}")

# ============================================================================
# LIVE TRADING SIMULATION PAGE
# ============================================================================

elif page == "Live Trading Simulation":
    st.header("üî¥ Live Trading Simulation")

    # Check if agents are trained
    if not st.session_state.trained_agents:
        st.warning("No trained agents found. Please train some agents first.")
        st.stop()

    # Agent selector
    agent_keys = list(st.session_state.trained_agents.keys())
    selected_agent = st.selectbox("Select Trained Agent", agent_keys)

    if selected_agent:
        st.subheader("üéÆ Simulation Controls")

        col1, col2, col3 = st.columns(3)

        with col1:
            initial_balance = st.number_input("Initial Balance ($)", 1000, 100000, 10000)

        with col2:
            transaction_cost = st.number_input("Transaction Cost (%)", 0.0, 1.0, 0.1, format="%.2f") / 100

        with col3:
            simulation_days = st.slider("Simulation Days", 30, 365, 90)

        # Start simulation button
        if st.button("üöÄ Start Live Simulation"):
            agent_type, symbol = selected_agent.split('_', 1)

            # Get latest data
            try:
                with st.spinner("Fetching latest market data..."):
                    end_date = datetime.now()
                    start_date = end_date - timedelta(days=simulation_days + 100)  # Extra days for indicators

                    ticker = yf.Ticker(symbol)
                    latest_data = ticker.history(start=start_date, end=end_date)

                    if len(latest_data) > 100:
                        # Apply feature engineering
                        pipeline = st.session_state.pipeline
                        processed_latest = pipeline.calculate_technical_indicators(latest_data)

                        # Take last simulation_days for actual simulation
                        sim_data = processed_latest[-simulation_days:].copy()

                        # Normalize using stored scalers
                        if symbol in pipeline.scalers:
                            price_cols = ['Open', 'High', 'Low', 'Close', 'Volume']
                            tech_cols = [col for col in sim_data.columns if col not in price_cols]

                            # Note: In production, you'd want to update scalers with recent data
                            # For demo, we'll use the stored scalers
                            sim_data_norm = sim_data.copy()

                            # Create simulation environment
                            sim_env = TradingEnvironment(sim_data_norm, initial_balance, transaction_cost)

                            # Run simulation
                            agent_result = st.session_state.trained_agents[selected_agent]
                            agent = agent_result['agent']

                            # Simulate trading
                            state = sim_env.reset()
                            done = False

                            portfolio_values = [initial_balance]
                            actions_taken = []

                            while not done:
                                if agent_type == 'DQN':
                                    agent.epsilon = 0  # No exploration in simulation
                                    action = agent.act(state)
                                else:  # PPO
                                    action, _ = agent.act(state)

                                actions_taken.append(action)
                                state, reward, done, info = sim_env.step(action)
                                portfolio_values.append(info['net_worth'])

                            # Display results
                            final_performance = sim_env.get_performance_metrics()

                            st.subheader("üìä Simulation Results")

                            col1, col2, col3, col4 = st.columns(4)

                            with col1:
                                st.metric("Final Return", f"{final_performance['total_return']:.2%}")

                            with col2:
                                st.metric("Total Trades", final_performance['num_trades'])

                            with col3:
                                st.metric("Final Balance", f"${final_performance['final_balance']:.2f}")

                            with col4:
                                st.metric("Net Worth", f"${final_performance['net_worth']:.2f}")

                            # Portfolio value chart
                            fig_portfolio = go.Figure()

                            # Portfolio value
                            fig_portfolio.add_trace(go.Scatter(
                                x=list(range(len(portfolio_values))),
                                y=portfolio_values,
                                mode='lines',
                                name='Portfolio Value',
                                line=dict(color='blue', width=2)
                            ))

                            # Buy and hold comparison
                            buy_hold_values = [initial_balance * (sim_data['Close'].iloc[i] / sim_data['Close'].iloc[0]) for i in range(len(sim_data))]
                            buy_hold_values = [initial_balance] + buy_hold_values

                            fig_portfolio.add_trace(go.Scatter(
                                x=list(range(len(buy_hold_values))),
                                y=buy_hold_values,
                                mode='lines',
                                name='Buy & Hold',
                                line=dict(color='red', width=2, dash='dash')
                            ))

                            fig_portfolio.update_layout(
                                title=f"Portfolio Performance - {symbol}",
                                xaxis_title="Days",
                                yaxis_title="Portfolio Value ($)",
                                hovermode='x unified'
                            )

                            st.plotly_chart(fig_portfolio, use_container_width=True)

                            # Action distribution
                            action_names = {0: 'Hold', 1: 'Buy', 2: 'Sell'}
                            action_counts = pd.Series(actions_taken).value_counts()
                            action_labels = [action_names.get(i, f'Action {i}') for i in action_counts.index]

                            fig_actions = go.Figure(data=[go.Pie(
                                labels=action_labels,
                                values=action_counts.values,
                                hole=0.3
                            )])

                            fig_actions.update_layout(title="Trading Actions Distribution")
                            st.plotly_chart(fig_actions, use_container_width=True)

                            # Trading log
                            if sim_env.trades:
                                st.subheader("üìù Trading Log")
                                trades_df = pd.DataFrame(sim_env.trades)
                                trades_df['date'] = sim_data.index[trades_df['step']].strftime('%Y-%m-%d')
                                st.dataframe(trades_df[['date', 'action', 'shares', 'price']], use_container_width=True)

                    else:
                        st.error("Insufficient recent data for simulation.")

            except Exception as e:
                st.error(f"Error in simulation: {str(e)}")

# ============================================================================
# MODEL COMPARISON PAGE
# ============================================================================
elif page == "Model Comparison":
    st.header("üîç Model Comparison")

    # Check if results exist
    if not st.session_state.results:
        st.warning("No trained agents found. Please train some agents first.")
        st.stop()

    # Group results by agent type and symbol
    dqn_results = {}
    ppo_results = {}

    for key, result in st.session_state.results.items():
        try:
            agent_type, symbol = key.split('_', 1)
            if agent_type == 'DQN':
                dqn_results[symbol] = result['performance']
            elif agent_type == 'PPO':
                ppo_results[symbol] = result['performance']
        except:
            continue

    # Create comparison data
    comparison_data = []

    # Get common symbols
    common_symbols = set(dqn_results.keys()) & set(ppo_results.keys())

    if not common_symbols:
        st.warning("No common symbols found for comparison. Please train both DQN and PPO agents on the same symbols.")
        st.stop()

    for symbol in common_symbols:
        dqn_perf = dqn_results[symbol]
        ppo_perf = ppo_results[symbol]

        comparison_data.extend([
            {
                'Agent': 'DQN',
                'Symbol': symbol,
                'Return': dqn_perf['total_return'],
                'Sharpe': dqn_perf['sharpe_ratio'],
                'Trades': dqn_perf['num_trades'],
                'Max_Drawdown': dqn_perf['max_drawdown']
            },
            {
                'Agent': 'PPO',
                'Symbol': symbol,
                'Return': ppo_perf['total_return'],
                'Sharpe': ppo_perf['sharpe_ratio'],
                'Trades': ppo_perf['num_trades'],
                'Max_Drawdown': ppo_perf['max_drawdown']
            }
        ])

    # Create DataFrame
    comparison_df = pd.DataFrame(comparison_data)

    # Plot comparison by return
    st.subheader("üìä Return Comparison")
    fig_return = px.bar(
        comparison_df,
        x="Symbol",
        y="Return",
        color="Agent",
        barmode="group",
        text=comparison_df["Return"].apply(lambda x: f"{x:.2%}"),
        title="DQN vs PPO: Total Return by Symbol"
    )
    fig_return.update_layout(yaxis_tickformat='.0%', xaxis_title="Asset", yaxis_title="Total Return")
    st.plotly_chart(fig_return, use_container_width=True)

    # Plot comparison by Sharpe Ratio
    st.subheader("üìà Sharpe Ratio Comparison")
    fig_sharpe = px.bar(
        comparison_df,
        x="Symbol",
        y="Sharpe",
        color="Agent",
        barmode="group",
        text=comparison_df["Sharpe"].round(2),
        title="DQN vs PPO: Sharpe Ratio by Symbol"
    )
    fig_sharpe.update_layout(xaxis_title="Asset", yaxis_title="Sharpe Ratio")
    st.plotly_chart(fig_sharpe, use_container_width=True)

    # Summary statistics
    st.subheader("üìä Summary Statistics")

    col1, col2 = st.columns(2)

    with col1:
        st.markdown("**DQN Performance:**")
        dqn_avg_return = comparison_df[comparison_df['Agent'] == 'DQN']['Return'].mean()
        dqn_avg_sharpe = comparison_df[comparison_df['Agent'] == 'DQN']['Sharpe'].mean()
        st.write(f"Average Return: {dqn_avg_return:.2%}")
        st.write(f"Average Sharpe: {dqn_avg_sharpe:.3f}")

    with col2:
        st.markdown("**PPO Performance:**")
        ppo_avg_return = comparison_df[comparison_df['Agent'] == 'PPO']['Return'].mean()
        ppo_avg_sharpe = comparison_df[comparison_df['Agent'] == 'PPO']['Sharpe'].mean()
        st.write(f"Average Return: {ppo_avg_return:.2%}")
        st.write(f"Average Sharpe: {ppo_avg_sharpe:.3f}")

    # Tabular view
    st.subheader("üìã Detailed Comparison Table")
    display_df = comparison_df.copy()
    display_df["Return"] = display_df["Return"].apply(lambda x: f"{x:.2%}")
    display_df["Sharpe"] = display_df["Sharpe"].round(3)
    display_df["Max_Drawdown"] = display_df["Max_Drawdown"].apply(lambda x: f"{x:.2%}")

    st.dataframe(display_df, use_container_width=True)

